<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Loading Wordmark Animation</title>

  <!-- Bootstrap CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-GtvN2N+ZK4t0j7BXAiHy6xYP5L0m3gKzbHOFcX3RZD7OjZCnZYKp6+I5NqF1hbGD"
    crossorigin="anonymous"
  />

  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #ffffff; /* white backdrop */
    }

    /* The canvas will fill the entire viewport */
    #three-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 998; /* stay above everything until animation ends */
    }

    /* Hide the navbar brand until animation finishes */
    #navbar-brand-wordmark {
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
  </style>
</head>
<body>
  <!-- Navbar (will stay at top-left after animation) -->
  <nav class="navbar navbar-expand-lg bg-white fixed-top border-bottom">
    <div class="container-fluid">
      <a class="navbar-brand fw-bold" id="navbar-brand-wordmark" href="#">
        BrandName
      </a>
    </div>
  </nav>

  <!-- Three.js canvas container -->
  <div id="three-container"></div>

  <!-- === External libraries === -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>
  <!-- Examples helpers (FontLoader & TextGeometry) -->
  <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
  <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>

  <!-- GSAP for smooth tweens -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script>
    // -------- CONFIGURATION --------
    const WORD = "BrandName"; // <-- CHANGE this to whatever word you need
    const LETTER_SIZE = 60; // font size in scene units
    const WORDMARK_OFFSET = { x: 100, y: 70 }; // final offset from top-left corner for the wordmark

    // -------- THREE.JS BASIC SETUP --------
    const container = document.getElementById("three-container");
    const scene = new THREE.Scene();

    // Use an orthographic camera so 1 unit == 1 pixel (easier positioning)
    let camera = createCamera(window.innerWidth, window.innerHeight);
    scene.add(camera);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xffffff, 0); // transparent to let white body show
    container.appendChild(renderer.domElement);

    // Track letter meshes so we can animate them later
    const letters = [];

    // Load the font then build letters
    const fontLoader = new THREE.FontLoader();
    fontLoader.load(
      "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
      (font) => {
        buildLetters(font);
        startAnimation();
      },
      undefined,
      (err) => console.error("Font loading failed", err)
    );

    // -------- FUNCTIONS --------
    function createCamera(w, h) {
      const cam = new THREE.OrthographicCamera(
        -w / 2,
        w / 2,
        h / 2,
        -h / 2,
        0.1,
        2000
      );
      cam.position.z = 1000; // pull camera back so everything is visible
      return cam;
    }

    function buildLetters(font) {
      const material = new THREE.MeshBasicMaterial({ color: 0x000000 });

      // Pre-calculate horizontal centering offset
      const totalWidth = WORD.length * LETTER_SIZE;
      const startX = -totalWidth / 2 + LETTER_SIZE / 2;

      for (let i = 0; i < WORD.length; i++) {
        const char = WORD[i];
        const geometry = new THREE.TextGeometry(char, {
          font: font,
          size: LETTER_SIZE,
          height: 2,
          curveSegments: 4,
        });
        geometry.computeBoundingBox();
        geometry.center();

        const mesh = new THREE.Mesh(geometry, material);

        // Scramble each letter within a loose box around screen center
        mesh.position.set(
          (Math.random() - 0.5) * 600,
          (Math.random() - 0.5) * 300,
          0
        );

        // Store where it needs to end up when forming the word
        mesh.userData.targetPos = new THREE.Vector3(
          startX + i * LETTER_SIZE,
          0,
          0
        );

        scene.add(mesh);
        letters.push(mesh);
      }
    }

    function startAnimation() {
      // Step 1: scramble already done â€“ now gather letters to center to form the word (1 second)
      const tl = gsap.timeline();

      tl.to(
        letters.map((l) => l.position),
        {
          duration: 1,
          x: (i) => letters[i].userData.targetPos.x,
          y: 0,
          ease: "power3.out",
          stagger: {
            // Slight overlap look
            each: 0.02,
          },
        }
      );

      // Step 2: push the whole word into the navbar (top-left)
      tl.addLabel("centered");
      tl.add(() => moveToNavbar(), "centered+=0.1");

      // After everything is done, reveal the real navbar text and clean up
      tl.add(() => finalize(), "+=1");
    }

    function moveToNavbar() {
      // Compute target position based on current viewport
      const targetX = -window.innerWidth / 2 + WORDMARK_OFFSET.x;
      const targetY = window.innerHeight / 2 - WORDMARK_OFFSET.y;

      gsap.to(letters.map((l) => l.position), {
        duration: 1,
        x: (i) => targetX + letters[i].userData.targetPos.x,
        y: targetY,
        ease: "power2.inOut",
        stagger: {
          each: 0.01,
        },
      });
    }

    function finalize() {
      // Reveal the real navbar wordmark
      document.getElementById("navbar-brand-wordmark").style.opacity = 1;

      // Fade out and remove the three.js canvas
      gsap.to(container, {
        duration: 0.6,
        opacity: 0,
        pointerEvents: "none",
        onComplete: () => {
          renderer.dispose();
          container.remove();
        },
      });
    }

    // -------- RENDER LOOP & RESIZE --------
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.left = -w / 2;
      camera.right = w / 2;
      camera.top = h / 2;
      camera.bottom = -h / 2;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  </script>

  <!-- Bootstrap JS (optional, for nav dropdowns etc.) -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-sCB7JyEjd5yh4m5l7D98LkcwdrGhUqgmT+NQ8Mk1GVIps7MxlVy2b2+/cy+5ylGj"
    crossorigin="anonymous"
  ></script>
</body>
</html>
