<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Team 496</title>
  <!--  Bootstrap  -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <style>
    /*  We want the canvas to fill the screen and sit behind everything  */
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden; /*   Prevent scroll-bars during the intro   */
      background: #ffffff;
    }

    #three-canvas {
      position: fixed;
      inset: 0; /*  Fill viewport  */
      display: block;
      z-index: 10; /*  Above regular content, below the navbar brand we will reveal */
    }

    /*  As soon as the animation finishes we reveal the normal brand sitting in the
        Bootstrap navbar.  */
    .navbar-brand.hidden {
      visibility: hidden;
    }
  </style>
</head>
<body>
  <!--  Placeholder navbar that the word-mark will snap into  -->
  <nav class="navbar bg-white px-3 position-relative" style="z-index: 15">
    <a class="navbar-brand fw-bold hidden" id="brand">Team&nbsp;496</a>
  </nav>

  <!--   Three.js goes on this canvas   -->
  <canvas id="three-canvas"></canvas>

  <!--  Three.js  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <!--  GSAP (for super-smooth tweens)  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <!--  Text helpers from the examples  -->
  <script type="module">
    import { FontLoader } from "https://unpkg.com/three@0.152.2/examples/jsm/loaders/FontLoader.js";
    import { TextGeometry } from "https://unpkg.com/three@0.152.2/examples/jsm/geometries/TextGeometry.js";

    /* ----------------------  Basic scene setup  ---------------------- */
    const canvas   = document.getElementById("three-canvas");
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 60;

    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    /* ----------------------  Create the letters  ---------------------- */
    const loader = new FontLoader();
    //  Use a bundled font from the three.js CDN
    loader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", (font) => {
      const message   = "Team 496";
      const material  = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
      const size      = 6; //   Font size in world units
      const gap       = 1; //   Extra spacing between letters in the final arrangement

      //  First measure total width so we can truly centre the word
      let totalWidth = 0;
      const letterGeometries = [];
      for (const ch of message) {
        const geo = new TextGeometry(ch, {
          font,
          size,
          height: 0.5,
          curveSegments: 4,
        });
        geo.computeBoundingBox();
        const w = geo.boundingBox.max.x - geo.boundingBox.min.x;
        totalWidth += w + gap;
        letterGeometries.push({ geo, width: w });
      }
      totalWidth -= gap; //  Remove last gap

      //  Create a mesh for each letter, place at random start pos
      const letters = [];
      let cursorX   = -totalWidth / 2; // Start so that word is centred when assembled

      for (const { geo, width } of letterGeometries) {
        const mesh = new THREE.Mesh(geo, material);

        //  Scramble position somewhere roughly in the middle third of the screen
        mesh.position.set(
          (Math.random() - 0.5) * 40, // x
          (Math.random() - 0.5) * 20, // y
          (Math.random() - 0.5) * 20  // z
        );

        // Store final position for the mesh
        mesh.userData.final = { x: cursorX, y: 0, z: 0 };
        cursorX += width + gap;

        scene.add(mesh);
        letters.push(mesh);
      }

      /* ----------------------  Animation timeline  ---------------------- */
      const tl = gsap.timeline({ defaults: { ease: "power2.inOut" } });

      //  1) Scrambled letters move to form the word – 1s duration
      letters.forEach((m) => {
        tl.to(
          m.position,
          {
            duration: 1,
            x: m.userData.final.x,
            y: m.userData.final.y,
            z: m.userData.final.z,
          },
          0 //  all start together (relative position 0 in the timeline)
        );
      });

      //  2) Entire word group slides to the navbar location (top-left) – 0.8s
      //  We'll treat the whole scene as a group by moving the camera target group.
      //  Easiest: animate a separate object3D as parent of letters.
      const wordGroup = new THREE.Group();
      letters.forEach((m) => wordGroup.add(m));
      scene.add(wordGroup);

      //  Calculate where the navbar brand is in world space.
      //  We'll map an approximate offset using the current camera frustum.
      const leftOffset = -window.innerWidth / 2 + 30;  //  30px right
      const topOffset  =  window.innerHeight / 2 - 50; //  50px down

      tl.to(wordGroup.position, { duration: 0.8, x: leftOffset / 10, y: topOffset / 10, z: 0 }, "+=0.2");

      //  3) Fade out the canvas & reveal the normal static brand
      tl.to(canvas, { duration: 0.5, opacity: 0, onComplete: () => {
        document.getElementById("brand").classList.remove("hidden");
        canvas.style.display = "none"; //  Keep DOM clean afterwards
      }});
    });

    /* ----------------------  Render loop  ---------------------- */
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
